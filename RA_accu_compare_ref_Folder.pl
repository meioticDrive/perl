#!/usr/bin/perl
#
# Name: RA_accu_compare_ref.pl
# Version 1.1
# Date: 09/08/2006
# Author: Michael E. Zwick
#--------------------------------------------------------------------------------------------
# 1. The purpose of this script is to compare reference_sequences to experimental fasta files 
# generated by RATools. The files are located withing a single folder (replaces process-test code)
# 2. The names of the fasta file and their corresponding reference file are hard coded in the 
# %chip_strain hash
# 3. User needs to provide name of folder containing all files (same as done for # RATools)
#
# Comments below need to be updated:
# B) The script will then enter a folder - whose name starts with a number. Typically, these folders # are the output of a parameter search - i.e. RA_run_param_srch.pl
# C) Fasta files present in the directory will be compared to a reference fasta file.
# D) Output will consist of the RATools parameters (from the folder name), the total number of bases # called, and the number of disrepancies in a tab delimited text file.
# The reference.chip.fasta file is generated from a high-quality (or at least 
# quality known) genbank reference sequence or alternative shotgun sequence data.
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
use warnings;
use strict;
use Cwd;

#-------------------------------------------------------------------------------
# Local variable definitions
#-------------------------------------------------------------------------------
# Define local variable

my(%chip_strain, @fasta_files, $first_file, $second_file, @first_seq, @second_seq, $first_seq_size, $second_seq_size, $bases_discrepant, $bases_identical, $bases_called_first_not_second, $bases_called_second_not_first, $bases_not_called_both, $grand_total_bases_first_not_second, $grand_total_bases_second_not_first, $check_total, $total_bases, $grand_total_bases_called_N, $grand_total_bases_different, $grand_total_bases_identical, $grand_total_check_total);

# Define local variables for localtime function
my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst);
#-------------------------------------------------------------------------------
# Initialize global variable values
#-------------------------------------------------------------------------------
$total_bases = 0;
$bases_identical = 0;
$bases_called_first_not_second = 0;
$bases_called_second_not_first = 0;
$bases_not_called_both = 0;
$bases_discrepant = 0;
$check_total = 0;
$grand_total_bases_identical = 0;
$grand_total_bases_first_not_second = 0;
$grand_total_bases_second_not_first = 0;
$grand_total_bases_called_N = 0;
$grand_total_bases_different = 0;
$grand_total_check_total = 0;

# Populate the %chip_strain hash with chip names and reference file to use for comparison
%chip_strain = (
'NA07029_GS_101_FMR-01.DAT.popgen.fasta' => 'NA07029_GS_501_FMR-01.DAT.popgen.fasta',
'NA07048_GS_101_FMR-01.DAT.popgen.fasta' => 'NA07048_GS_501_FMR-01.DAT.popgen.fasta',
'NA10846_GS_101_FMR-01.DAT.popgen.fasta' => 'NA10846_GS_501_FMR-01.DAT.popgen.fasta',
'NA10851_GS_101_FMR-01.DAT.popgen.fasta' => 'NA10851_GS_501_FMR-01.DAT.popgen.fasta',
'NA10860a_GS_501_FMR-01.DAT.popgen.fasta' => 'NA10860b_GS_501_FMR-01.DAT.popgen.fasta',
'NA18500_GS_501_FMR-01.DAT.popgen.fasta' => 'NA18500_GS_601_FMR-01.DAT.popgen.fasta',
'NA18503_GS_101_FMR-01.DAT.popgen.fasta' => 'NA18503_GS_501_FMR-01.DAT.popgen.fasta',
'NA18506_GS_101_FMR-01.DAT.popgen.fasta' => 'NA18506_GS_501_FMR-01.DAT.popgen.fasta',
'NA18515_GS_101_FMR-01.DAT.popgen.fasta' => 'NA18515_GS_501_FMR-01.DAT.popgen.fasta',
'NA18521_GS_501_FMR-01.DAT.popgen.fasta' => 'NA18521_GS_601_FMR-01.DAT.popgen.fasta',
'Tr91_GS_101_FMR-01.DAT.popgen.fasta' => 'Tr91_GS_201_FMR-01.DAT.popgen.fasta',
);

#-------------------------------------------------------------------------------
#Update required

# Enter into the reference sequence directory
# Read in all the reference sequences
# Remove all fasta headers and spaces
# Place reference sequence into a string
# Read reference sequences into an array
# Put into an array for comparison




# Loop over experimental files
# Read experimental files into arrays one at a time
# Perform comparison with .reference.chip file
# Count number of bases that are N, identical, different


# Update
# Loop over all all files within a single folder
# 		Selected Chip File Name
# 		Use hash to select correct comparison file
# 		Compare sequences
# 		Add up results
# 		Output results
# 		

# Change to directory entered by user when calling the program
#--------------------------------------------------------------------------------------------
chdir $ARGV[0] or die "Cannot change to directory $ARGV[0]\n";

# Remove old replicate files
system ("rm *.count.txt");

# Collect the names of fasta files for processing
@fasta_files = glob("*.fasta");				# Individual RA sequences'

	#Open output file for number of discrepancies
	open(OUT_DISCREPANCIES, ">", "replication.discrepancy.count.txt") 
		or die "Cannot open OUT_FASTA for data output";

# Process fasta file, make hash relating fasta labels to sequence
#--------------------------------------------------------------------------------------------
foreach my $process_file (@fasta_files) {

	# Check to see if hash contains key. If so, process file
	if (exists $chip_strain{$process_file}) {
	
		# Process reference files to generate single DNA sequence file
	# Read file in line by line, discard fasta header
	# Remove spaces, put string into arrays for each different reference sequence
	
	# Process key file
	open(FILEHANDLE_FIRST, $process_file)
		or die "Cannot open FILEHANDLE_FIRST";
	print "Process first file: $process_file\n";
	while (<FILEHANDLE_FIRST>) {
		if ($_ =~ /^>/) {
				next;
			}
			else {
				$first_file .= $_;
			}
		}	
		close FILEHANDLE_FIRST;
		$first_file =~ s/\s//g;	# Remove spaces from string
		#print OUT_DISCREPANCIES "First file: $first_file\n";
		@first_seq = split( '', $first_file);
		$first_seq_size = ($#first_seq + 1);
	
	# Process replicate file (name from hash)
	open(FILEHANDLE_SECOND, $chip_strain{$process_file})
		or die "Cannot open FILEHANDLE_SECOND";
	print "Process second file: $chip_strain{$process_file}\n";
	while (<FILEHANDLE_SECOND>) {
		if ($_ =~ /^>/) {
				next;
			}
			else {
				$second_file .= $_;
			}
		}	
		close FILEHANDLE_SECOND;
		$second_file =~ s/\s//g;	# Remove spaces from string
		#print OUT_DISCREPANCIES "Second file: $second_file\n";
		@second_seq = split( '', $second_file);
		$second_seq_size = ($#second_seq + 1);
	
	# Compare two files to each other
	if ($first_seq_size != $second_seq_size) {
		print "Warning: Files being compared:\n
					$process_file\n
					$chip_strain{$process_file}\n
					are not the same size. Exiting program\n";
		exit;
		}

	print "Entering the comparison loop\n";
	# Loop for haploid comparison between sequences
	for (my $i = 0; $i < $second_seq_size; $i++) {
		#print OUT_DISCREPANCIES "First: $first_seq[$i]\tSecond: $second_seq[$i]\n";
		$total_bases++;

# Count bases called identically in both fasta files
	if (($first_seq[$i] eq "A") && ($second_seq[$i] eq "A")) {
		$bases_identical++;
		next;
	} 
	elsif (($first_seq[$i] eq "C") && ($second_seq[$i] eq "C")) {
		$bases_identical++;
		next;
	} 
	elsif (($first_seq[$i] eq "G") && ($second_seq[$i] eq "G")) {
		$bases_identical++;
		next;
	} 
	elsif (($first_seq[$i] eq "T") && ($second_seq[$i] eq "T")) {
		$bases_identical++;
		next;
	}
	else {
	}

# Count bases called in first file, but not second file
	if (($first_seq[$i] eq "A") && ($second_seq[$i] eq "N")) {
		$bases_called_first_not_second++;
		next;
	} 
	elsif (($first_seq[$i] eq "C") && ($second_seq[$i] eq "N")) {
		$bases_called_first_not_second++;
		next;
	} 
	elsif (($first_seq[$i] eq "G") && ($second_seq[$i] eq "N")) {
		$bases_called_first_not_second++;
		next;
	} 
	elsif (($first_seq[$i] eq "T") && ($second_seq[$i] eq "N")) {
		$bases_called_first_not_second++;
		next;
	}

# Count bases called in second file, but not first file
	if (($first_seq[$i] eq "N") && ($second_seq[$i] eq "A")) {
		$bases_called_second_not_first++;
		next;
	} 
	elsif (($first_seq[$i] eq "N") && ($second_seq[$i] eq "C")) {
		$bases_called_second_not_first++;
		next;
	} 
	elsif (($first_seq[$i] eq "N") && ($second_seq[$i] eq "G")) {
		$bases_called_second_not_first++;
		next;
	} 
	elsif (($first_seq[$i] eq "N") && ($second_seq[$i] eq "T")) {
		$bases_called_second_not_first++;
		next;
	}

	# Count bases not called in either fasta file
	if (($first_seq[$i] eq "N") && ($second_seq[$i] eq "N")) {
		$bases_not_called_both++;
		next;
	}
	
# Count discrepant base calls: if base get here - must be discrepant
	print "Found discrepancy\n";
	$bases_discrepant++;
	print OUT_DISCREPANCIES "First sequence: $first_seq[$i]\t Second Sequence: $second_seq[$i]\t Position: " . ($i + 1) ."\n";
	}
	
	# Collect summary data for a single fasta chip file
	$check_total = ($bases_identical +  + $bases_called_first_not_second + $bases_called_second_not_first + $bases_not_called_both + $bases_discrepant);
	
	# Collect grand total information for a given set of parameters (directory)
	#---------------------------------------------------------------------------
	$grand_total_bases_identical = $grand_total_bases_identical + $bases_identical;
	$grand_total_bases_first_not_second = $grand_total_bases_first_not_second + $bases_called_first_not_second;
	$grand_total_bases_second_not_first = $grand_total_bases_second_not_first + $bases_called_second_not_first;
	$grand_total_bases_called_N = $grand_total_bases_called_N + $bases_not_called_both;
	$grand_total_bases_different = $grand_total_bases_different + $bases_discrepant;
	$grand_total_check_total = $grand_total_check_total + $check_total;
	
	print OUT_DISCREPANCIES "Number of based called identically: $bases_identical\n";
	print OUT_DISCREPANCIES "Number of bases called in first, called N in second: $bases_called_first_not_second\n";
	print OUT_DISCREPANCIES "Number of bases called in second, called N in first: $bases_called_second_not_first\n";
	print OUT_DISCREPANCIES "Number of bases called N in both: $bases_not_called_both\n";
	print OUT_DISCREPANCIES "Number of discrepant bases: $bases_discrepant\n";
	print OUT_DISCREPANCIES "Total bases for these chips: $check_total\n\n";
	
	# Reset variable values
	@first_seq = ();
	@second_seq = ();
	$first_file = '';
	$second_file = '';
	$bases_identical = 0;
	$bases_called_first_not_second = 0;
	$bases_called_second_not_first = 0;
	$bases_not_called_both = 0;
	$bases_discrepant = 0;
	$check_total = 0;
	} 
	else {
		# Process to next fasta file if not defined in hash %chip_strain
		print "Entered the else loop\n";
		next;
	}
}


	# Debug Codef
	
	print "Total called identical on both: $grand_total_bases_identical\n";
	print "Number of bases called in first, called N in second: $grand_total_bases_first_not_second\n";
	print "Number of bases called in second, called N in first: $grand_total_bases_second_not_first\n";
	print "Called N: $grand_total_bases_called_N\n";
	print "Called Different: $grand_total_bases_different\n";
	print "Total: $grand_total_check_total\n";

	# Output grand_total information for a given set of parameters (directory)
	#---------------------------------------------------------------------------
	print OUT_DISCREPANCIES "---------------------------------------------------------------------------\n";
	print OUT_DISCREPANCIES "Called Identical: $grand_total_bases_identical\n";
	print OUT_DISCREPANCIES "Number of bases called in first, called N in second: $grand_total_bases_first_not_second\n";
	print OUT_DISCREPANCIES "Number of bases called in second, called N in first: $grand_total_bases_second_not_first\n";
	print OUT_DISCREPANCIES "Called N: $grand_total_bases_called_N\n";
	print OUT_DISCREPANCIES "Called Different: $grand_total_bases_different\n";
	print OUT_DISCREPANCIES "Total: $grand_total_check_total\n";
	print OUT_DISCREPANCIES "---------------------------------------------------------------------------\n";
close OUT_DISCREPANCIES;
print ("Exiting RA_accu_compare_ref_Folder.pl script\n");

#--------------------------------------------------------------------------
#--------------------------------------------------------------------------
# Subroutines
#--------------------------------------------------------------------------
#--------------------------------------------------------------------------
